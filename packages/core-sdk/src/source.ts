import { z } from 'zod';
import type { Plugin, Config, Input, Output } from './plugin';
import { ErrorDetailsSchema, createConfigSchema } from './plugin';

/**
 * Zod schema for the Author interface
 */
export const authorSchema = z.object({
  id: z.string().optional(),
  username: z.string().optional(),
  displayName: z.string().optional(),
  url: z.string().optional(),
});

/**
 * Zod schema for PluginSourceItem - defines the structure that plugins must return
 */
export const pluginSourceItemSchema = z.object({
  externalId: z.string(),
  content: z.string(),
  contentType: z.string().optional(),
  createdAt: z.string().optional(),
  url: z.string().optional(),
  authors: z.array(authorSchema).optional(),
  raw: z.unknown(),
});

/**
 * Standard content types supported by the system.
 * Plugins can extend this with custom types.
 */
export const ContentType = {
  POST: 'post',
  ARTICLE: 'article',
  VIDEO: 'video',
  PODCAST: 'podcast',
  WEBSITE: 'website',
  FEED: 'feed',
  DATABASE_ENTRY: 'database-entry',
  UNKNOWN: 'unknown',
} as const;

export type ContentType = typeof ContentType[keyof typeof ContentType];

/**
 * Represents a single author - derived from the authorSchema
 */
export type Author = z.infer<typeof authorSchema>;

/**
 * Base PluginSourceItem type derived from schema (with unknown raw type)
 */
export type BasePluginSourceItem = z.infer<typeof pluginSourceItemSchema>;

/**
 * This is the data structure a plugin is responsible for creating.
 * It's generic over the raw data type.
 */
export interface PluginSourceItem<TRaw = Record<string, any>> extends Omit<BasePluginSourceItem, 'raw'> {
  // The raw, untouched data from the source API
  raw: TRaw;
}

/**
 * This is the final, canonical data structure used within the system.
 * It extends PluginSourceItem with system-generated fields.
 */
export interface SourceItem<TRaw = Record<string, any>> extends PluginSourceItem<TRaw> {
  id: string; // Unique internal ID, generated by the worker
  createdAt: string; // Guaranteed to exist (worker provides a default)
  
  // System-injected metadata for traceability
  metadata: {
    sourcePlugin: string;
    jobId: string;
    runId: string;
    [key: string]: any;
  };
}

/**
 * Defines the progress of a job submitted to an external asynchronous service (e.g., Masa).
 */
export interface AsyncJobProgress {
  jobId: string;
  status: "submitted" | "pending" | "processing" | "done" | "error" | "timeout";
  submittedAt: string; // ISO timestamp
  lastCheckedAt?: string; // ISO timestamp
  errorMessage?: string;
  // Optionally, store the original query or parameters for this job
  // queryDetails?: Record<string, any>;
}

/**
 * Generic platform-specific state for managing resumable searches and long-running jobs.
 */
export interface PlatformState {
  // For overall resumable search (across multiple jobs/chunks)
  // This cursor can be a string, number, or a more complex object
  // depending on the platform's pagination/cursor mechanism.
  latestProcessedId?: string | number | Record<string, any>;

  // For the currently active job (e.g., a Masa search job for one chunk)
  currentAsyncJob?: AsyncJobProgress | null;

  // Allows for other platform-specific state variables
  [key: string]: any;
}

/**
 * State passed between search calls to enable resumption.
 * TData is expected to be an object conforming to PlatformState or a derivative.
 */
export interface LastProcessedState<
  TData extends PlatformState = PlatformState,
> {
  // The `data` field holds the strongly-typed, platform-specific state.
  data: TData;
  // Optional: A unique identifier for this state object itself, if needed for storage/retrieval.
  // id?: string;
  // Optional: Timestamp of when this state was generated.
  // timestamp?: number;
}

/**
 * Configuration options for a specific search operation by a SourcePlugin.
 * TPlatformOpts allows for platform-specific arguments.
 */
export interface SourcePluginSearchOptions<
  TPlatformOpts = Record<string, any>,
> {
  type: string; // e.g., "twitter-scraper", "reddit-scraper". The plugin will interpret this.
  query?: string; // General query string. Its interpretation depends on the plugin and the 'type'.
  pageSize?: number; // General hint for how many items to fetch per request. The plugin/service might override or interpret this.
  platformArgs?: TPlatformOpts; // Typed platform-specific arguments

  // Allows for additional dynamic arguments if needed.
  [key: string]: any;
}

// Standard Service Interface for platform-specific search services
export interface IPlatformSearchService<
  TItem extends PluginSourceItem,
  TPlatformOptions = Record<string, unknown>,
  TPlatformState extends PlatformState = PlatformState,
> {
  initialize?(config?: any): Promise<void>;
  search(
    options: TPlatformOptions,
    currentState: LastProcessedState<TPlatformState> | null,
  ): Promise<{ items: TItem[]; nextStateData: TPlatformState | null }>;
  shutdown?(): Promise<void>;
}

// Source-specific plugin types that extend the base plugin types
export type SourceConfig<
  V extends z.ZodTypeAny = z.ZodRecord<z.ZodString, z.ZodUnknown>,
  S extends z.ZodTypeAny = z.ZodRecord<z.ZodString, z.ZodUnknown>
> = Config<V, S>;

export interface SourceInput<TSearchOptions = SourcePluginSearchOptions> extends Input<z.ZodAny> {
  searchOptions: TSearchOptions;
  lastProcessedState?: PlatformState | null;
}

// The output data from a source plugin (before system enrichment)
export interface PluginSourceOutputData<TItem extends PluginSourceItem = PluginSourceItem> {
  items: TItem[];
  nextLastProcessedState?: PlatformState | null;
}

// The output from a source plugin's execute method
export interface PluginSourceOutput<TItem extends PluginSourceItem = PluginSourceItem> extends Output<z.ZodAny> {
  success: boolean;
  data?: PluginSourceOutputData<TItem>;
  errors?: Array<{ message: string; details?: Record<string, unknown>; stack?: string }>;
}

// The final output data after system enrichment (used internally by workers)
export interface SourceOutputData {
  items: SourceItem[];
  nextLastProcessedState?: PlatformState | null;
}

// The final output after system enrichment (used internally by workers)
export interface SourceOutput extends Output<z.ZodAny> {
  success: boolean;
  data?: SourceOutputData;
  errors?: Array<{ message: string; details?: Record<string, unknown>; stack?: string }>;
}

// Source plugin interface that extends the base Plugin interface
export interface SourcePlugin<
  TInput extends SourceInput = SourceInput,
  TOutput extends PluginSourceOutput = PluginSourceOutput,
  TConfig extends SourceConfig = SourceConfig
> extends Plugin<TInput, TOutput, TConfig> {
  readonly type: 'source';
}

// Source-specific schema creators
export const createSourceInputSchema = <TSearchOptions extends z.ZodTypeAny>(
  searchOptionsSchema: TSearchOptions
) =>
  z.object({
    searchOptions: searchOptionsSchema,
    lastProcessedState: z.record(z.string(), z.unknown()).optional().nullable(),
  });

export const createSourceOutputSchema = <TItem extends z.ZodTypeAny>(
  itemSchema: TItem
) =>
  z.object({
    success: z.boolean(),
    data: z.object({
      items: z.array(itemSchema),
      nextLastProcessedState: z.record(z.string(), z.unknown()).optional().nullable(),
    }).optional(),
    errors: z.array(ErrorDetailsSchema).optional(),
  });
